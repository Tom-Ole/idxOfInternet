<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Graph Visualization</title>

    <script src="https://unpkg.com/deck.gl@latest/dist.min.js"></script>


    <style>
        body {
            width: 100vw;
            height: 100vh;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        #container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        #tooltip {
            position: absolute;
            background: white;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 3px;
            font-family: Arial, sans-serif;
            font-size: 12px;
            pointer-events: none;
            display: none;
            z-index: 9;
        }
    </style>
</head>

<body>

    <div id="container"></div>
    <div id="tooltip"></div>

    <script>
        const { DeckGL, OrthographicView, ScatterplotLayer, LineLayer } = deck;
        const tooltip = document.getElementById('tooltip');

        // Helper function to show tooltip
        function showTooltip(x, y, content) {
            tooltip.style.display = 'block';
            tooltip.style.left = x + 10 + 'px';
            tooltip.style.top = y + 10 + 'px';
            tooltip.innerHTML = content;
        }

        // Helper function to hide tooltip
        function hideTooltip() {
            tooltip.style.display = 'none';
        }

        async function fetchData() {
            try {
                const nodesResponse = await fetch('http://localhost:8080/nodes');
                const nodesData = await nodesResponse.json();

                const edgesResponse = await fetch('http://localhost:8080/edges');
                const edgesData = await edgesResponse.json();

                console.log('Nodes:', nodesData);
                console.log('Edges:', edgesData);

                return {
                    nodes: nodesData,
                    edges: edgesData
                };
            } catch (error) {
                console.error('Error fetching data:', error);
                // Return sample data as fallback
                return {
                    nodes: [
                        { id: "n1", title: "Node 1", weight: 3, x: -100, y: 0 },
                        { id: "n2", title: "Node 2", weight: 2, x: 100, y: 0 },
                        { id: "n3", title: "Node 3", weight: 4, x: 0, y: 100 },
                        { id: "n4", title: "Node 4", weight: 1, x: 0, y: -100 }
                    ],
                    edges: [
                        { from: "n1", to: "n2" },
                        { from: "n1", to: "n3" },
                        { from: "n2", to: "n4" },
                        { from: "n3", to: "n4" }
                    ]
                };
            }
        }

        fetchData().then(({ nodes, edges }) => {
            // Create a node map for edge processing
            const nodeMap = {};
            nodes.forEach(node => {
                nodeMap[node.id] = node;
            });

            // Process edges to include positions
            // const processedEdges = edges.filter(edge => {
            //     return nodeMap[edge.from] && nodeMap[edge.to];
            // }).map(edge => {
            //     const source = nodeMap[edge.from];
            //     const target = nodeMap[edge.to];
            //     return {
            //         sourcePosition: [source.x, source.y],
            //         targetPosition: [target.x, target.y],
            //         from: edge.from,
            //         to: edge.to,
            //         source,
            //         target
            //     };
            // });

            // Helper to generate a bundled curve between two points
            function generateBundledPath(source, target, strength = 0.2) {
                const midX = (source.x + target.x) / 2;
                const midY = (source.y + target.y) / 2 - strength * Math.abs(source.x - target.x); // offset curve
                return [
                    [source.x, source.y],
                    [midX, midY],
                    [target.x, target.y]
                ];
            }

            // Process edges into bundled paths
            const processedEdges = edges.filter(edge => {
                return nodeMap[edge.from] && nodeMap[edge.to];
            }).map(edge => {
                const source = nodeMap[edge.from];
                const target = nodeMap[edge.to];
                return {
                    path: generateBundledPath(source, target),
                    from: edge.from,
                    to: edge.to,
                    source,
                    target
                };
            });


            // Calculate bounds to center the view
            const xs = nodes.map(n => n.x);
            const ys = nodes.map(n => n.y);
            const minX = Math.min(...xs);
            const maxX = Math.max(...xs);
            const minY = Math.min(...ys);
            const maxY = Math.max(...ys);

            // Calculate center and range
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            const rangeX = Math.max(maxX - minX, 200);
            const rangeY = Math.max(maxY - minY, 200);

            // Get width and height of the viewport
            const width = window.innerWidth;
            const height = window.innerHeight;

            // Calculate zoom to fit all nodes with padding
            const padding = 50;
            const scaleX = (width - padding * 2) / rangeX;
            const scaleY = (height - padding * 2) / rangeY;
            const scale = Math.min(scaleX, scaleY);

            // Create an orthographic view
            const view = new OrthographicView({
                id: 'ortho',
                controller: true,
                controllerSettings: {
                    dragPan: true,
                    dragRotate: false,
                    scrollZoom: true,
                    doubleClickZoom: true,
                    touchZoom: true,
                    touchRotate: false,
                    keyboard: true
                }
            });


            // Create the layers
            const layers = [
                // Edge layer
                // new LineLayer({
                //     id: 'edges',
                //     data: processedEdges,
                //     getWidth: 1.5,
                //     getSourcePosition: d => [d.sourcePosition[0], d.sourcePosition[1]],
                //     getTargetPosition: d => [d.targetPosition[0], d.targetPosition[1]],
                //     getColor: [120, 120, 180],
                //     pickable: true,
                //     onHover: info => {
                //         if (info.object) {
                //             showTooltip(info.x, info.y, `
                //                 <strong>Edge</strong><br>
                //                 From: ${info.object.source.title || info.object.from}<br>
                //                 To: ${info.object.target.title || info.object.to}
                //             `);
                //         } else {
                //             hideTooltip();
                //         }
                //     }
                // }),
                new deck.PathLayer({
                    id: 'edges',
                    data: processedEdges,
                    getPath: d => d.path,
                    getWidth: 0.5,
                    getColor: [120, 120, 180],
                    pickable: true,
                    onHover: info => {
                        if (info.object) {
                            showTooltip(info.x, info.y, `
                <strong>Edge</strong><br>
                From: ${info.object.source.title || info.object.from}<br>
                To: ${info.object.target.title || info.object.to}
            `);
                        } else {
                            hideTooltip();
                        }
                    }
                }),
                // Node layer
                new ScatterplotLayer({
                    id: 'nodes',
                    data: nodes,
                    getPosition: d => [d.x, d.y],
                    getRadius: d => (5 + Math.sqrt(d.weight || 1) * 3),
                    getFillColor: [0, 128, 255],
                    getLineColor: [255, 255, 255],
                    lineWidthMinPixels: 1,
                    stroked: true,
                    filled: true,
                    pickable: true,
                    onHover: info => {
                        if (info.object) {
                            showTooltip(info.x, info.y, `
                                <strong>${info.object.title || info.object.id}</strong><br>
                                Weight: ${info.object.weight || 'N/A'}
                            `);
                        } else {
                            hideTooltip();
                        }
                    }
                })
            ];

            // Create the initial view state
            const initialViewState = {
                target: [centerX, centerY, 0],
                zoom: scale,
                minZoom: -10,
                maxZoom: 100
            };

            // Create and attach the DeckGL instance
            let deckgl = new DeckGL({
                container: 'container',
                views: [view],
                viewState: initialViewState,
                controller: true,
                layers: layers,
                getTooltip: ({ object }) => object && {
                    html: `<div>${object.title || object.id}</div>`,
                    style: {
                        backgroundColor: '#fff',
                        fontSize: '12px'
                    }
                },
                onViewStateChange: ({ viewState: vs }) => {
                    viewState = vs;
                    deckgl.setProps({ viewState });
                }
            });

            // Add a message to the console to confirm initialization
            console.log('Graph visualization initialized');
        }).catch(error => {
            console.error('Error initializing visualization:', error);
            // Display error on the screen for better debugging
            document.body.innerHTML += `
                <div style="position:absolute; top:10px; left:10px; background:white; padding:10px; border:1px solid red;">
                    Error initializing graph: ${error.message}
                </div>
            `;
        });
    </script>
</body>

</html>